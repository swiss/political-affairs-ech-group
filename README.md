# eCH Specialist Group Political Affairs

This repository contains the documents and resources of the [eCH](https://ech.ch/) [Specialist Group Political Affairs](https://www.ech.ch/de/fachgruppen/politische-geschaefte) (Fachgruppe Politische Geschäfte / Groupe spécialisé affaires politiques).

## Subgroups

The specialist group is divided into different subgroups. Each subgroup is responsible for a specific topic. The following subgroups exist:

- eCH-0292: [Metaprozesse zu politischen Geschäften (meta)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0292_meta)
- eCH-0293: [Öffentlicher Ratsbetrieb (operations)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0293_operations)
- eCH-0294: [Politische Akteure: Personen, Gruppen und Organe (actors)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0294_actors)
- eCH-0295: [Parlamentarische Geschäfte (affairs)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0295_affairs)
- eCH-0296: [Erlasse und Gesetzestexte (laws)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0296_laws)
- eCH-0297: [Öffentliche Konsultationen (consultations)](https://github.com/swiss/political-affairs-ech-group/tree/main/ech-0297_consultations)

## Tutorial

There is also the folder `tutorial` that demonstrates, how to use the [LinkML](https://linkml.io/linkml/index.html) toolchain to create a data model for the eCH Specialist Group Political Affairs.

## Data-Centric Approach

The eCH Specialist Group Political Affairs uses a data-centric approach to develop its data schemata. This means that the **data schemata are the primary artifacts**. [LinkML](https://linkml.io/linkml/) is used to describe the data schema which in turn is also used to auto-generate parts of the documentation.

## Workflow

Manual steps:

- Description of the data schema in YAML using LinkML in the `input` folder of each subgroup in the file `schema.yaml`.
- Generate example data conforming to the schema in the files `data_xyz.yaml` in the `input` folder.
- Write the accompanying documentation in Markdown with files in the form of `1_head.md`, `2_intro.md` (`number_subject.md`) in the `input` folder.

Automated steps (every commit that changes files in the `input` folder triggers a GitHub Action that automatically):

- Generates a schema in JSON and OWL (TTL) format from the `schema.yaml` file and stores it in the `output` folder as `schema.json` and `schema.ttl`.
- Converts the example data in `data_xyz.yaml` to JSON and RDF (TTL) format and stores it in the `output` folder as `data_xyz.json` and `data_xyz.ttl`.
- Generates the documentation using the `linkml-doc` tool. The generated documentation is stored as individual Markdown files in the `output/docs` folder.
- Creates a unified Markdown file from all the files in the `input` folder and stores it as `output/documentation_merged.md`.
- Converts the unified Markdown file from the `output` folder to DOCX using `pandoc` and a `template.docx` file in the `input` folder and stores it in the `output` folder.

### Include Autogenerated Documentation

To include the autogenerated documentation from `output/docs` into the final DOCX document, use the following syntax in the Markdown files in the `input` folder:

`{{include:path_to_md_file}}` e.g. `{{include:tutorial/output/docs/AgendaItem.md}}`

## Subgroup Folder Structure

Each subgroup has its own folder. The folder structure is as follows:

```
subgroup-name/
├── input/
│   ├── schema.yaml
│   ├── data_x.yaml
│   ├── data_y.yaml
│   ├── ...
│   ├── data_z.yaml
│   ├── 1_topic_1.md
│   ├── 2_topic_2.md
│   ├── ...
│   ├── n_topic_n.md
│   ├── template.docx
├── misc/
│   ├── YYMMDD.md (for meeting notes)
│   ├── ...
├── output/
│   ├── docs/
│   ├── data_x.json
│   ├── ...
│   ├── data_x.ttl
│   ├── ...
│   ├── schema.json
│   ├── schema.ttl
│   ├── documentation_merged.md
│   ├── subgroup-name.docx
```

## LinkML Learnings

In this section, we will share our learnings and experiences with LinkML. This includes tips and tricks, best practices, and any challenges we faced during the development of the data schema. We will also provide links to relevant resources and documentation that we found helpful.

### Multilingualism

Unfortunately, LinkML does not support multilingualism out of the box. However there are some workarounds that we used to achieve some level of multilingualism:

Multilingual descriptions of LinkML elements should be provided in the `description` field of the element. Use the following syntax in the `schema.yaml` file:

```yaml
description: |
  [en] This is the description in English.
  [de] Das ist die deutsche Beschreibung.
```

This leads to a quite ok-ish autogenerated documentation (e.g. in index.md the descriptions are sometimes shortened) but allows later on to create separate translations of the documentation.

Multilingual data objects can be achieved by using a `MultilingualString` type. This type allows you to define a string with language tags. The schema needs to include:

```yaml
classes:
  MultilingualString:
    slots:
      - text
      - language
  Object:
    slots:
      - name
slots:
  text:
    required: true
  language:
    slot_uri: dcterm:language
    required: true
    pattern: ^[a-z]{2}$
  name:
    slot_uri: schema:name
    range: MultilingualString
    multivalued: true
    inlined_as_list: true
```

And an example of data could look like this:

```yaml
name:
  - text: "Agenda Item 1"
    language: "en"
  - text: "Geschäftsgegenstand 1"
    language: "de"
```

There seems to be no simple solution to allow a string to either be a `MultilingualString` or a simple string. Therefore, we recommend to use the `MultilingualString` type for all strings that are in a certain language even if there is no translation intended.

### Reusing Slots

It seems not possible to have a different descriptions for slots used in different classes. So slots should only be reused if a fairly general description is enough (like for a `id` or a `name`). For all other cases, it is better to define a new slot with a more specific name and description.

### Attributes vs Slots

Properties can either be defined within a class as `attribute` and then, they are exclusive to that class or as `slot` which can be reused across different classes. If there are different classes that define the same `attribute` (even with different descriptions), this will result in a warning (but it seems that one can live with it).

### Capitalization with Regards to Classes and Attributes/Slots

If a class and an attribute/slot share the same name but differ only in capitalization (e.g. class `Person` and slot `person`), this will lead to issues in the generated documentation files because they will only differ in capitalization which some operating systems do not respect.

### Data Types and Formats

When defining data types and formats in LinkML, consider the following guidelines:

- if a slot is designated as `identifier: true`, the corresponding value must be a CURIE, e.g. `id: ops:1234` and not `id: 1234`.
- if a slot needs to be a date with time, use `range: datetime` and give the value in the format `YYYY-MM-DDTHH:MM:SSZ` (UTC) or `YYYY-MM-DDTHH:MM:SS+01:00` (UTC + 1).
