# LinkML Guidelines

In this section, we will share our learnings and experiences with LinkML. This includes tips and tricks, best practices, and any challenges we faced during the development of the data schema. We will also provide links to relevant resources and documentation that we found helpful.

## Classes vs. Type Attributes

If there are entities that share all the same attributes with exception of one. It is better to define a common class and use a `type` attribute to distinguish between the different entities instead of defining separate classes for each entity.

## Multilingualism

Unfortunately, LinkML does not support multilingualism out of the box. However there are some workarounds that we used to achieve some level of multilingualism:

Multilingual descriptions of LinkML elements should be provided in the `description` field of the element. Use the following syntax in the `schema.yaml` file:

```yaml
description: |
  [en] This is the description in English.
  [de] Das ist die deutsche Beschreibung.
```

This leads to a quite ok-ish autogenerated documentation (e.g. in index.md the descriptions are sometimes shortened) but allows later on to create separate translations of the documentation.

Multilingual data objects can be achieved by using a `MultilingualString` type. This type allows you to define a string with language tags. The schema needs to include:

```yaml
classes:
  MultilingualString:
    slots:
      - text
      - language
  Object:
    slots:
      - name
slots:
  text:
    required: true
  language:
    slot_uri: dcterm:language
    required: true
    pattern: ^[a-z]{2}$
  name:
    slot_uri: schema:name
    range: MultilingualString
    multivalued: true
    inlined_as_list: true
```

And an example of data could look like this:

```yaml
name:
  - text: "Agenda Item 1"
    language: "en"
  - text: "Gesch√§ftsgegenstand 1"
    language: "de"
```

There seems to be no simple solution to allow a string to either be a `MultilingualString` or a simple string. Therefore, we recommend to use the `MultilingualString` type for all strings that are in a certain language even if there is no translation intended.

## Reusing Slots

It seems not possible to have a different descriptions for slots used in different classes. So slots should only be reused if a fairly general description is enough (like for a `id` or a `name`). For all other cases, it is better to define a new slot with a more specific name and description.

## Attributes vs Slots

Properties can either be defined within a class as `attribute` and then, they are exclusive to that class or as `slot` which can be reused across different classes. If there are different classes that define the same `attribute` (even with different descriptions), this will result in a warning (but it seems that one can live with it).

## Capitalization with Regards to Classes and Attributes/Slots

If a class and an attribute/slot share the same name but differ only in capitalization (e.g. class `Person` and slot `person`), this will lead to issues in the generated documentation files because they will only differ in capitalization which some operating systems do not respect.

## Data Types and Formats

When defining data types and formats in LinkML, consider the following guidelines:

- if a slot is designated as `identifier: true`, the corresponding value must be a CURIE, e.g. `id: ops:1234` and not `id: 1234`.
- if a slot needs to be a date with time, use `range: datetime` and give the value in the format `YYYY-MM-DDTHH:MM:SSZ` (UTC) or `YYYY-MM-DDTHH:MM:SS+01:00` (UTC + 1). It is not possible to use `datetime` with only a date, so if there is only a date but no time, use `range: date` and give the value in the format `YYYY-MM-DD`.

## Hierarchies

There is often the need to build hierarchies, e.g. :

- Legislatures contain
- Sessions contain
- Meetings contain
- Meeting Items

## Using schema.org for Hierarchies

The most basic model to build a hierarchy is by using `schema:hasPart` (pointing from higher level hierarchy to lower level; from generic to specific) and `schema:isPartOf` (pointing from lower level hierarchy to higher level; from specific to generic). These predicates can be used withouth too many restrictions. From using `schema:hasPart` and `schema:isPartOf`, one cannot directly infer which class to expect.

## Creating Specific Hierarchies

Very specific predicates, like `parentMeeting` or `childSession` can be created with the advantage, that the class of the target object can be inferred by the name of the predicate.

Advice: Use always some words like child or parent to symbolize the belonging to a hierarchy. Do not use words like session to link from a meeting to a session above or from a legislature to a session below because this will not make it obvious that is a link to another hierarchy level and also not which direction within the hierarchy.

Pluralization: In RDF, there won't be any pluralization in predicates (e.g. no childSessions), in LinkML one can choose to create a slot child_sessions stating that there could be many of them.

Linking-Target: The linking should always be to the URI of the object and therefore there is no need to create predicates like parentMeetingId.

Linking-Direction: There is no rule whether to use linking from above to below or vice-versa or always in both direction. Sometimes, there are so many child items that a linking only from child to parent is preferred to not "bloat" the parent object.
